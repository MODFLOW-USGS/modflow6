module ExchangeFactoryModule
  use KindModule, only: I4B, LGP
  use ConstantsModule, only: LENMEMPATH, LINELENGTH, LENEXCHANGENAME
  use SimModule, only: store_error, count_errors
  use SimVariablesModule, only: iout, idm_context, model_names, model_loc_idx
  use MemoryHelperModule, only: create_mem_path
  use MemoryManagerModule, only: mem_setptr, mem_allocate
  use CharacterStringModule, only: CharacterStringType
  use ArrayHandlersModule, only: ifind

  implicit none
  private
  #:if any(EXCHANGES)
  public :: create_exchanges
  #:endif

contains

  #:for e in EXCHANGES
  #! split on hyphen
  #:set l = e.split('-')[0]
  #:set r = e.split('-')[1]
  #! uppercase
  #:set luc = l.upper()  
  #:set ruc = r.upper()
  #! camelcase                                 
  #:set lcc = l[0].upper() + l[1:]  
  #:set rcc = r[0].upper() + r[1:]
  subroutine create_${l}$${r}$_exchange( &
    fname, &
    exg_id, &
    both_local, &
    both_remote, &
    m1_id, m2_id, &
    exg_mempath)
    ! -- modules
    use ${lcc}$${rcc}$ExchangeModule, only: ${l}$${r}$_cr
    #:if l == r
    use Virtual${lcc}$${rcc}$ExchangeModule, only: add_virtual_${l}$${r}$_exchange
    #:endif
    ! -- dummy
    character(len=LINELENGTH), intent(in) :: fname
    integer(I4B), intent(in) :: exg_id
    logical(LGP), intent(in) :: both_local
    logical(LGP), intent(in) :: both_remote
    integer(I4B), intent(in) :: m1_id
    integer(I4B), intent(in) :: m2_id
    character(len=LENMEMPATH), intent(in) :: exg_mempath
    ! -- local
    character(len=LENEXCHANGENAME) :: exg_name

    write (exg_name, '(a,i0)') '${luc}$-${ruc}$_', exg_id
    #:if l == r
    if (.not. both_remote) &
    #:else
    if (both_local) &
    #:endif
      call ${l}$${r}$_cr( &
      fname, &
      exg_name, &
      exg_id, &
      m1_id, &
      m2_id, &
      exg_mempath)
    #:if l == r
    call add_virtual_${l}$${r}$_exchange( &
      exg_name, &
      exg_id, &
      m1_id, &
      m2_id)
    #:endif
  end subroutine create_${l}$${r}$_exchange

  #:endfor
  #:if any(EXCHANGES)
  subroutine create_exchanges(etypes, efiles, emnames_a, emnames_b, emempaths)
    ! -- dummy
    type(CharacterStringType), dimension(:), contiguous, &
      pointer, intent(in) :: etypes !< exg types
    type(CharacterStringType), dimension(:), contiguous, &
      pointer, intent(in) :: efiles !< exg file names
    type(CharacterStringType), dimension(:), contiguous, &
      pointer, intent(in) :: emnames_a !< model a names
    type(CharacterStringType), dimension(:), contiguous, &
      pointer, intent(in) :: emnames_b !< model b names
    type(CharacterStringType), dimension(:), contiguous, &
      pointer, intent(in) :: emempaths
    ! -- local
    integer(I4B) :: exg_id, n
    integer(I4B) :: m1_id, m2_id
    logical(LGP) :: both_remote, both_local
    character(len=LINELENGTH) :: fname, name1, name2
    character(len=LENMEMPATH) :: exg_mempath
    character(len=LINELENGTH) :: errmsg, exgtype
    ! -- formats
    character(len=*), parameter :: fmtmerr = "('Error in simulation control ', &
      &'file.  Could not find model: ', a)"

    exg_id = 0
    do n = 1, size(etypes)
      exgtype = etypes(n)
      fname = efiles(n)
      name1 = emnames_a(n)
      name2 = emnames_b(n)
      exg_mempath = emempaths(n)
      exg_id = exg_id + 1

      ! find model index in list
      m1_id = ifind(model_names, name1)
      if (m1_id < 0) then
        write (errmsg, fmtmerr) trim(name1)
        call store_error(errmsg, terminate=.true.)
      end if
      m2_id = ifind(model_names, name2)
      if (m2_id < 0) then
        write (errmsg, fmtmerr) trim(name2)
        call store_error(errmsg, terminate=.true.)
      end if

      ! both models on other process? then don't create it here...
      both_remote = (model_loc_idx(m1_id) == -1 .and. &
                     model_loc_idx(m2_id) == -1)
      both_local = (model_loc_idx(m1_id) > 0 .and. &
                    model_loc_idx(m2_id) > 0)
      if (.not. both_remote) write (iout, '(4x,a,a,i0,a,i0,a,i0)') &
        trim(exgtype), ' exchange ', exg_id, &
        ' will be created to connect model ', m1_id, &
        ' with model ', m2_id

      select case (exgtype)
      #:for e in EXCHANGES
      #! split on hyphen
      #:set l = e.split('-')[0]
      #:set r = e.split('-')[1]
      #! uppercase
      #:set luc = l.upper()  
      #:set ruc = r.upper()
      #! camelcase                                 
      #:set lcc = l[0].upper() + l[1:]  
      #:set rcc = r[0].upper() + r[1:]
      case ('${luc}$6-${ruc}$6')
        call create_${l}$${r}$_exchange( &
          fname, &
          exg_id, &
          both_local, &
          both_remote, &
          m1_id, &
          m2_id, &
          exg_mempath)
      #:endfor
      case default
        write (errmsg, '(a,a)') &
          'Unknown simulation exchange type: ', trim(exgtype)
        call store_error(errmsg, terminate=.true.)
      end select
    end do
  end subroutine create_exchanges
  #:endif

end module ExchangeFactoryModule
